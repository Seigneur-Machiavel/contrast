// @ts-check
if (false) { const anime = require('animejs'); } // For completion

import { ADDRESS } from '../../types/address.mjs';
import { eHTML_STORE } from '../board-helpers.js';
import { MiniformComponent } from './miniform-component.js';
import { AccountsComponent } from './accounts-component.js';
import { Wallet, Account } from '../../node/src/wallet.mjs';
import { Transaction_Builder } from '../../node/src/transaction.mjs';
import { BLOCKCHAIN_SETTINGS } from '../../utils/blockchain-settings.mjs';
import { serializer } from '../../utils/serializer.mjs';
import { CURRENCY } from '../../utils/currency.mjs';

/** @typedef {import("../../types/transaction.mjs").Transaction} Transaction */

const eHTML = new eHTML_STORE('biw-', 'container');
const horizontalBtnLoading = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid" width="200" height="200" style="shape-rendering: auto;display: block;width: 100%;height:200%;transform: translate(0, -25%);"><g><circle fill="#c4c4c4" r="10" cy="50" cx="84"><animate begin="0s" keySplines="0 0.5 0.5 1" values="10;0" keyTimes="0;1" calcMode="spline" dur="0.25s" repeatCount="indefinite" attributeName="r"/><animate begin="0s" values="#c4c4c4;#424242;#6e6e6e;#959595;#c4c4c4" keyTimes="0;0.25;0.5;0.75;1" calcMode="discrete" dur="1s" repeatCount="indefinite" attributeName="fill"/></circle><circle fill="#c4c4c4" r="10" cy="50" cx="16"><animate begin="0s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="0;0;10;10;10" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="r"/><animate begin="0s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="16;16;16;50;84" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="cx"/></circle><circle fill="#959595" r="10" cy="50" cx="50"><animate begin="-0.25s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="0;0;10;10;10" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="r"/><animate begin="-0.25s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="16;16;16;50;84" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="cx"/></circle><circle fill="#6e6e6e" r="10" cy="50" cx="84"><animate begin="-0.5s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="0;0;10;10;10" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="r"/><animate begin="-0.5s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="16;16;16;50;84" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="cx"/></circle><circle fill="#424242" r="10" cy="50" cx="16"><animate begin="-0.75s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="0;0;10;10;10" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="r"/><animate begin="-0.75s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="16;16;16;50;84" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="cx"/></circle><g/></g><!-- [ldio] generated by https://loading.io --></svg>';

class InstructionsReader { // TO ENHANCE
    validChars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';

	/** @param {string} instructionsStr */
    read(instructionsStr) {
		const safeStr = this.#asSafeReadable(instructionsStr);
        if (!safeStr) return 'Invalid instructions';

        try {
			const instructions = safeStr.split(' ');
			if (!['SEND', 'STAKE', 'UNSTAKE', 'INSCRIBE'].includes(instructions[0]))
				return `Invalid action: ${instructions[0]}`;
			
			/** @ts-ignore @type {'SEND' | 'STAKE' | 'UNSTAKE' | 'INSCRIBE'} */
			const action = instructions[0];
            const amount = this.#parseFloatIfSafeAndValidContrastAmount(instructions[1])
				|| BLOCKCHAIN_SETTINGS.unspendableUtxoAmount + 1; // to avoid 0 or dust amounts

            const address = instructions[2] === 'TO' ? instructions[3] : null;
			if (address && !ADDRESS.checkConformity(address)) return `Invalid address: ${address}`;

            const dataStr = action === 'INSCRIBE' ? instructions[1]
				: instructions.indexOf('DATA') > -1 ? instructions[instructions.indexOf('DATA') + 1]
				: null;
			if (typeof dataStr !== 'string' && dataStr !== null) return 'Invalid data field';
    
            return { action, amount, address, dataStr };
        } catch (error) { return 'Invalid instructions'; }
    }
    #asSafeReadable(str = '') {
        if (typeof str !== 'string') return;
        const safeStr = str.trim().toUpperCase();
        for (let i = 0; i < safeStr.length; i++) if (!this.validChars.includes(safeStr[i])) return;
        return safeStr;
    }
    #parseFloatIfSafeAndValidContrastAmount(value = '') {
        if (typeof value !== 'string') return false;
        if (value.length < 1 || value.length > 14) return false;
        for (let i = 0; i < value.length; i++) if (!'0123456789.'.includes(value[i])) return false;

        // no more than 6 decimals
        if (value.includes('.') && value.split('.')[1].length > 6) return false;
        return parseFloat(value);
    }
}

export class BoardInternalWallet {
	// @ts-ignore
	components = {											// @ts-ignore
		/** @type {MiniformComponent} */ miniform: null, 	// @ts-ignore
		/** @type {AccountsComponent} */ accounts: null,
	}

	eHTML = eHTML;
	autoRefresh = true;
	wallet = new Wallet("0000000000000000000000000000000000000000000000000000000000000000");
	instructionsReader = new InstructionsReader();
	boardStorage;
	connector;

	animations = {};
    standardFeePerByte = { "fast": 12, "average": 5, "slow": 2 };
	/** @type {string | null} */			currentTextInfo = null;
	/** @type {NodeJS.Timeout | null} */	textInfoTimeout1 = null;
    /** @type {NodeJS.Timeout | null} */	textInfoTimeout2 = null;

	/** @param {import('../connector.js').Connector} connector @param {import('../../utils/front-storage.mjs').FrontStorage} boardStorage */
	constructor(connector, boardStorage) {
		this.connector = connector;
		this.boardStorage = boardStorage;
		this.#initWhileDomReady();
	}

	// INTERNAL METHODS
	async #initWhileDomReady() {
		if (!eHTML.isReady) console.log('BIW awaiting DOM elements...');
		while (!eHTML.isReady) await new Promise(r => setTimeout(r, 200));
		console.log('BIW DOM elements ready.');

		this.components.miniform = new MiniformComponent(this);
		this.components.accounts = new AccountsComponent(eHTML.get('accountsWrap'), this);
		await this.#loadUserPreferences();

		/** @ts-ignore @type {string | null} */
		const savedPrivateKey = await this.boardStorage.load('board_internal_wallet_private_key');
		const privateKey = savedPrivateKey || Wallet.generateRandomMasterHex();
        this.wallet = new Wallet(privateKey);
        await this.wallet.loadAccountsFromFrontStorage(this.boardStorage);
		this.components.accounts.updateLabels();
		if (this.wallet.accounts.length > 0) this.selectAccountLabel(this.wallet.accounts[0].address);

		this.connector.on('consensus_height_change', this.#onConsensusHeightChange);
    }

	#onConsensusHeightChange = async (newHeight = 0) => {
	}
	#getWalletAccountIndexByAddress(address = '') {
        for (let j = 0; j < this.wallet.accounts.length; j++)
			if (this.wallet.accounts[j].address === address) return j;
        return -1;
    }
	async #generateNewAddress() {
		const btn = eHTML.get('newAddressBtn');
		const isGenerating = eHTML.get('newAddressBtn')?.innerHTML !== '+';
		if (!btn || isGenerating) return;

		this.textInfo('Generating account...');
		btn.classList.add('loading');
		btn.innerHTML = horizontalBtnLoading;

		// START ANIMATION
		let animation = anime({
			targets: btn,
			width: ['80px', '200px', '80px'],
			duration: 1600,
			loop: true,
			easing: 'easeInOutQuad'
		});

		await this.wallet.deriveOneAccount('C', undefined, this.boardStorage);
		await new Promise(r => setTimeout(r, 800)); // wait a bit to show the animation
		this.components.accounts.updateLabels();

		// STOP ANIMATION
		btn.classList.remove('loading');
		animation.pause();
		animation = anime({
			targets: btn,
			width: '34px',
			duration: 200,
			easing: 'easeInOutQuad',
			complete: () => { btn.innerHTML = '+'; }
		});
	}
	/** @param {HTMLInputElement} inputElement */
    #inputElementValueToAmount(inputElement) {
        const a = Number(inputElement.value.replaceAll(",",""));
        const b = a.toFixed(6).replaceAll(".","");
        return parseInt(b);
    }
    #followInstructionsFromInput() {
		/** @ts-ignore @type {HTMLInputElement} */
		const instructionsInput = eHTML.get('instructionsInput');
		if (!instructionsInput) throw new Error('Instructions input element not found');

		const sender = this.wallet.accounts[this.components.accounts.activeAccountIndex]?.address;
		if (!sender) throw new Error('No active account selected to send from');

		const instructions = this.instructionsReader.read(instructionsInput.value);
        instructionsInput.value = ''; // reset field after reading instructions

        if (typeof instructions === 'string') { // @ts-ignore
            this.textInfo(instructions);
            return;
        }

		const { action, amount, address, dataStr } = instructions;
		this.components.miniform.open(action);
		this.components.miniform.setValues(
			amount,
			address || sender,
			dataStr	? dataStr : undefined
		)
    }
	#saveUserPreferences() {
		const userPreferences = { // @ts-ignore
			autoRefresh: eHTML.get('autoRefreshCheckbox')?.checked || false, // @ts-ignore
			enableCommands: eHTML.get('enableCommandsCheckbox')?.checked || false, // @ts-ignore
			enableDataField: eHTML.get('enableDataFieldCheckbox')?.checked || false,
		};

		this.boardStorage.save('board_internal_wallet_user_preferences', JSON.stringify(userPreferences));
	}
	async #loadUserPreferences() {
		const d = await this.boardStorage.load('board_internal_wallet_user_preferences');
		if (!d) return;

		try { // @ts-ignore
			const userPreferences = JSON.parse(d); // @ts-ignore
			eHTML.get('autoRefreshCheckbox').checked = userPreferences.autoRefresh; // @ts-ignore
			eHTML.get('enableCommandsCheckbox').checked = userPreferences.enableCommands; // @ts-ignore
			eHTML.get('enableDataFieldCheckbox').checked = userPreferences.enableDataField;
			if (userPreferences.autoRefresh) this.autoRefresh = true;
			if (userPreferences.enableCommands) eHTML.get('buttonBarSpecial')?.classList.remove('hidden');
			if (userPreferences.enableDataField) eHTML.get('dataField')?.classList.remove('hidden');
		} catch (error) { console.error('Error loading user preferences:', error); }
	}
	// HANDLERS METHODS
	// @ts-ignore
	clickHandler(e) {
		if (!e.target.dataset.action) return;
		
		const parent = e.target.parentElement;
		switch(e.target.dataset.action) {
			case 'biw-refresh':
				console.log('buttonRefresh');
				break;
			case 'biw-toggle-settings-menu':
				eHTML.get('settings-menu')?.classList.toggle('open');
				break;
			case 'biw-auto-refresh-toggle':
				this.autoRefresh = e.target.checked;
				this.#saveUserPreferences();
				break;
			case 'biw-enable-commands-toggle':
				if (e.target.checked) eHTML.get('buttonBarSpecial')?.classList.remove('hidden');
				else eHTML.get('buttonBarSpecial')?.classList.add('hidden');
				this.#saveUserPreferences();
				break;
			case 'biw-enable-data-field-toggle':
				if (e.target.checked) eHTML.get('data-field')?.classList.remove('hidden');
				else eHTML.get('data-field')?.classList.add('hidden');
				this.#saveUserPreferences();
				break;
			case 'biw-new-address':
				this.#generateNewAddress();
				break;
			case 'biw-select-account':
				this.selectAccountLabel(e.target.dataset.value);
				break;
			case 'biw-toogle-send-form':
				if (this.components.miniform.isExpanded()) this.components.miniform.close();
				else this.components.miniform.open('send');
				break;
			case 'biw-toogle-special-menu':
				eHTML.get('buttonBarSpecial')?.classList.toggle('open');
				eHTML.get('specialMenu')?.classList.toggle('open');
				break;
			case 'biw-interpret-input-btn':
				this.#followInstructionsFromInput();
				eHTML.get('buttonBarSpecial')?.classList.remove('open');
				eHTML.get('specialMenu')?.classList.remove('open');
				break;
		}
	}

	// API METHODS
	/** @param {string} text @param {HTMLElement | null} [infoElmnt] @param {number} [timeout] @param {boolean} [eraseAnyCurrentTextInfo] @param {boolean} [important] */
	textInfo(text, infoElmnt = eHTML.get('globalTextInfo'), timeout = 3000, eraseAnyCurrentTextInfo = false, important = false) {
		if (!infoElmnt) return;
        if (!eraseAnyCurrentTextInfo && this.currentTextInfo) return;

        this.currentTextInfo = text;
        infoElmnt.innerText = text;
        infoElmnt.style.opacity = '1';
        if (important) infoElmnt.classList.add('important');

        if (this.textInfoTimeout1) clearTimeout(this.textInfoTimeout1);
        if (this.textInfoTimeout2) clearTimeout(this.textInfoTimeout2);

        this.textInfoTimeout1 = setTimeout(() => {
            this.currentTextInfo = null;
            infoElmnt.style.opacity = '0';
            infoElmnt.classList.remove('important');
        }, timeout);
        this.textInfoTimeout2 = setTimeout(() => infoElmnt.innerText = "", timeout + 200);
    }
	/** @param {string} address */
    selectAccountLabel(address) {
		const accountIndex = this.#getWalletAccountIndexByAddress(address);
		this.components.accounts.setActiveAccountIndex(accountIndex);
		this.components.miniform.setSenderAddress(address);
		console.log(`Selected account: ${address}`);
    }

	// OLD API METHODS - MAINLY DEPRECATED
    async refreshActiveAccounts() {
        this.eHTML.buttonRefresh.classList.add('active');
        // refresh all accounts data
		for (const account of this.wallet.accounts) {
            this.fetcher.send({ type: 'get_address_exhaustive_data', data: account.address });
            await new Promise((resolve) => setTimeout(() => resolve(), 10));
        }
        await new Promise((resolve) => setTimeout(() => resolve(), 1000));
        this.eHTML.buttonRefresh.classList.remove('active');
    }
    holdBtnMouseUpAnimation(target, invertColors = false, duration = 1000) {
        const leftColor = invertColors ? 'var(--color1)' : 'var(--color2)';
        const rightColor = invertColors ? 'var(--color2)' : 'var(--color1)';
        const initialBackground = `linear-gradient(90deg, ${leftColor} 0%, ${rightColor} 0%)`;
    
        return anime({
            targets: target,
            background: initialBackground,
            duration,
            easing: 'easeInOutQuad',
            complete: () => target.style.background = `linear-gradient(90deg, ${rightColor} 0%, ${leftColor} 0%)`
        });
    }
    holdBtnMouseDownAnimation(target, callback, invertColors = false, duration = 2000) {
        const computedStyle = getComputedStyle(target);
        const bImage = computedStyle.backgroundImage;
        const perc1 = bImage === 'none' ? 0 : bImage.split('%')[0].split(' ')[bImage.split('%')[0].split(' ').length - 1];
        const perc2 = bImage === 'none' ? 0 : bImage.split('%')[1].split(' ')[bImage.split('%')[1].split(' ').length - 1];
        
        const leftColor = invertColors ? 'var(--color1)' : 'var(--color2)';
        const rightColor = invertColors ? 'var(--color2)' : 'var(--color1)';
        target.style.background = `linear-gradient(90deg, ${leftColor} ${perc1}%, ${rightColor} ${perc2}%)`;
    
        return anime({
            targets: target,
            background: `linear-gradient(90deg, ${leftColor} 100%, ${rightColor} 102%)`,
            duration,
            easing: 'easeInOutQuad',
            complete: () => {
                callback();
                target.style.background = `linear-gradient(90deg, ${leftColor} 0%, ${rightColor} 0%)`;
            }
        });
    }
    /** @param {UTXO[]} utxos */
    async extractDataFromAccountUTXOs(utxos) {
        let balance = 0;
        let spendableBalance = 0;
        let stakedBalance = 0;
        const spendableUTXOs = [];

        for (const utxo of utxos) {
            balance += utxo.amount;
            if (utxo.rule === 'sigOrSlash') { stakedBalance += utxo.amount; continue; }

            spendableUTXOs.push(utxo);
            spendableBalance += utxo.amount;
        }

        return { balance, spendableBalance, stakedBalance, spendableUTXOs };
    }
    /** @param {string | boolean} foldName - false to close all */
    #setButtonBarActiveButton(foldName = "send") {
        const buttons = this.eHTML.buttonBar.element.getElementsByTagName('button');
        for (const button of buttons) button.classList.remove('active');

        if (!foldName) return;

        let targetBtnName = foldName;
        if (targetBtnName === 'instructions') targetBtnName = 'special';
        if (targetBtnName === 'claim') targetBtnName = 'special';

        this.eHTML.buttonBar[targetBtnName].classList.add('active');
    }
}