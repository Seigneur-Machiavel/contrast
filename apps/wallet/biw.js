if (false) { // For better completion
	const anime = require('animejs');
}

/**
 * @typedef {import("../../node/src/transaction.mjs").UTXO} UTXO
 * @typedef {import("../../node/src/transaction.mjs").TransactionWithDetails} TransactionWithDetails
 * @typedef {import("../../node/front/explorerScript.mjs").BlockExplorerWidget} BlockExplorerWidget
 * 
 * @typedef {import("../../node/src/wallet.mjs").Wallet} Wallet
 * @typedef {import("../../node/src/wallet.mjs").Account} Account
 * @typedef {import("../../node/src/wallet.mjs").Transaction} Transaction
 * @typedef {import("../../node/src/wallet.mjs").Transaction_Builder} Transaction_Builder
 * @typedef {import("../../node/src/wallet.mjs").utxoExtraction} utxoExtraction
 * 
 * @typedef {import("../../utils/converters.mjs").convert} convert
 * @typedef {import("../../utils/type-validation.mjs").typeValidation} typeValidation
 * @typedef {import("../../utils/addressUtils.mjs").addressUtils} addressUtils
 */

const { ipcRenderer } = require('electron');
const horizontalBtnLoading = '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid" width="200" height="200" style="shape-rendering: auto;display: block;width: 100%;height:200%;transform: translate(0, -25%);"><g><circle fill="#c4c4c4" r="10" cy="50" cx="84"><animate begin="0s" keySplines="0 0.5 0.5 1" values="10;0" keyTimes="0;1" calcMode="spline" dur="0.25s" repeatCount="indefinite" attributeName="r"/><animate begin="0s" values="#c4c4c4;#424242;#6e6e6e;#959595;#c4c4c4" keyTimes="0;0.25;0.5;0.75;1" calcMode="discrete" dur="1s" repeatCount="indefinite" attributeName="fill"/></circle><circle fill="#c4c4c4" r="10" cy="50" cx="16"><animate begin="0s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="0;0;10;10;10" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="r"/><animate begin="0s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="16;16;16;50;84" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="cx"/></circle><circle fill="#959595" r="10" cy="50" cx="50"><animate begin="-0.25s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="0;0;10;10;10" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="r"/><animate begin="-0.25s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="16;16;16;50;84" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="cx"/></circle><circle fill="#6e6e6e" r="10" cy="50" cx="84"><animate begin="-0.5s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="0;0;10;10;10" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="r"/><animate begin="-0.5s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="16;16;16;50;84" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="cx"/></circle><circle fill="#424242" r="10" cy="50" cx="16"><animate begin="-0.75s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="0;0;10;10;10" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="r"/><animate begin="-0.75s" keySplines="0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1;0 0.5 0.5 1" values="16;16;16;50;84" keyTimes="0;0.25;0.5;0.75;1" calcMode="spline" dur="1s" repeatCount="indefinite" attributeName="cx"/></circle><g/></g><!-- [ldio] generated by https://loading.io --></svg>';
const PatternGenerator = require("./scripts/pattern-generator.js");
const patternGenerator = new PatternGenerator({ width: 48, height: 48, scale: 1 });
const UX_SETTINGS = { shapes: 4 };
/*let Wallet, Account, Transaction, Transaction_Builder, utxoExtraction;
let convert, typeValidation, addressUtils;*/


class WalletDataFetcher {
    RECONNECT_INTERVAL = 2000;
    /** @type {WebSocket} */
    ws;
    onMessageHandler;

    /** @param {function} onMessageHandler */
    constructor(onMessageHandler) {
        this.onMessageHandler = onMessageHandler;
        this.#connectWSLoop();
    }

    #connectWS() {
        this.ws = new WebSocket('ws://localhost:27270');
        this.ws.onopen = this.#onOpen.bind(this);
        this.ws.onclose = this.#onClose.bind(this);
        this.ws.onerror = this.#onError.bind(this);
        this.ws.onmessage = this.onMessageHandler;
    }
    async #connectWSLoop() {
        this.#connectWS();
        while (true) {
            await new Promise((resolve) => { setTimeout(() => { resolve(); }, this.RECONNECT_INTERVAL); });
            if (this.ws && this.ws.readyState === 1) { continue; }
            
            this.#connectWS();
        }
    }
    #onOpen() {
        console.log('----- Connection opened -----');
    }
    #onClose() {
        console.info('----- Connection closed -----');
        this.ws = undefined;
    }
    #onError(error) {
        console.info('WebSocket error: ' + JSON.stringify(error));
        this.ws = undefined;
    }
    
    async send(message) {
        while (!this.ws || this.ws.readyState !== 1) { await new Promise((resolve) => { setTimeout(() => { resolve(); }, 100); }); }
        this.ws.send(JSON.stringify(message));
    }
}

class InstructionsReader {
    validChars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    constructor() {}

    #isSafe(str = '') {
        if (typeof str !== 'string') return false;
        str = str.trim();
        for (let i = 0; i < str.length; i++) {
            if (!this.validChars.includes(str[i])) { return false; }
        }

        return true;
    }
    #parseIntIfSafe(value) { // DEPRECATED
        if (typeof value !== 'string') return false;
        if (value.length > 14) return false;
        for (let i = 0; i < value.length; i++) {
            if (!'0123456789'.includes(value[i])) return false;
        }

        return parseInt(value);
    }
    #parseFloatIfSafeAndValidContrastAmount(value) {
        if (typeof value !== 'string') return false;
        if (value.length > 14) return false;
        for (let i = 0; i < value.length; i++) {
            if (!'0123456789.'.includes(value[i])) return false;
        }

        // no more than 6 decimals
        if (value.includes('.') && value.split('.')[1].length > 6) return false;

        return parseFloat(value);
    }
    /** @param {string} instructionsStr */
    read(instructionsStr) {
        if (!this.#isSafe()) { return 'Invalid instructions'; }

        try {
            const instructions = instructionsStr.split(' ');
            const action = instructions[0].toUpperCase();
            let amount;
            let inscription;
            let address;
            switch (action) {
                case 'SEND':
                case 'STAKE':
                    amount = this.#parseFloatIfSafeAndValidContrastAmount(instructions[1]);
                    if (!amount) { return `Invalid amount: ${instructions[1]}`; }
                    break;
                case 'INSCRIBE':
                    inscription = instructions[1];
                    break;
                default:
                    return `Invalid action: ${action}`;
            }
            
            if (instructions[2] && instructions[2].toUpperCase() === 'TO') {
                try {
                    window.addressUtils.conformityCheck(instructions[3]);
                    address = instructions[3];
                } catch (error) { return `Invalid address: ${instructions[3]}`; }
            }
    
            return { action, amount, inscription, address };
        } catch (error) { return 'Invalid instructions'; }
    }
}

class BoardInternalWallet {
    instructionsReader = new InstructionsReader();
    /** @type {Wallet} */
    wallet;
    /** @type {WalletDataFetcher} */
    fetcher;
    wsSubscriptions = {
        /** @type {Object<string, boolean>} */
        balanceUpdates: {}
    }
    animations = {};
    eHTML = {
        container: document.getElementById('biw-container'),
        spendableBalanceStr: document.getElementById('biw-spendableBalanceStr'),
        stakedStr: document.getElementById('biw-stakedStr'),
        accountsWrap: document.getElementById('biw-accountsWrap'),
        newAddressBtn: document.getElementById('biw-newAddressBtn'),

        buttonBar: {
            element: document.getElementsByClassName('biw-buttonBar')[0],
            send: document.getElementById('biw-buttonBarSend'),
            swap: document.getElementById('biw-buttonBarSwap'),
            stake: document.getElementById('biw-buttonBarStake'),
            special: document.getElementById('biw-buttonBarSpecial'),
        },

        sendBtn: document.getElementById('biw-sendBtn'),
        swapBtn: document.getElementById('biw-swapBtn'),
        stakeBtn: document.getElementById('biw-stakeBtn'),
        
        specialBtn: document.getElementById('biw-buttonBarSpecial'),
        specialMenu: document.getElementById('biw-specialMenu'),
        instructionsBtn: document.getElementById('biw-buttonBarInstructions'),
        claimBtn: document.getElementById('biw-buttonBarSpecialClaim'),

        send: {
            miniForm: document.getElementById('biw-spendMiniForm'),
            foldBtn: document.getElementById('biw-spendMiniForm').getElementsByTagName('button')[0],
            textInfo: document.getElementById('biw-spendMiniForm').getElementsByClassName('biw-textInfo')[0],
            senderAddress: document.getElementById('biw-spendMiniForm').getElementsByClassName('biw-senderAddress')[0],
            amount: document.getElementById('biw-spendMiniForm').getElementsByTagName('input')[0],
            toAddress: document.getElementById('biw-spendMiniForm').getElementsByTagName('input')[1],
            txFee: document.getElementById('biw-spendMiniForm').getElementsByClassName('biw-txFee')[0],
            totalSpent: document.getElementById('biw-spendMiniForm').getElementsByClassName('biw-totalSpent')[0],
            confirmBtn: document.getElementById('biw-spendMiniForm').getElementsByTagName('button')[1]
        },
        stake: {
            miniForm: document.getElementById('biw-stakeMiniForm'),
            foldBtn: document.getElementById('biw-stakeMiniForm').getElementsByTagName('button')[0],
            textInfo: document.getElementById('biw-stakeMiniForm').getElementsByClassName('biw-textInfo')[0],
            senderAddress: document.getElementById('biw-stakeMiniForm').getElementsByClassName('biw-senderAddress')[0],
            toAddress: document.getElementById('biw-stakeMiniForm').getElementsByTagName('input')[0],
            amount: document.getElementById('biw-stakeMiniForm').getElementsByTagName('input')[1],
            txFee: document.getElementById('biw-stakeMiniForm').getElementsByClassName('biw-txFee')[0],
            stakingFee: document.getElementById('biw-stakeMiniForm').getElementsByClassName('biw-stakingFee')[0],
            totalSpent: document.getElementById('biw-stakeMiniForm').getElementsByClassName('biw-totalSpent')[0],
            confirmBtn: document.getElementById('biw-stakeMiniForm').getElementsByTagName('button')[1]
        },
        instructions: {
            miniForm: document.getElementById('biw-instructionsMiniForm'),
            foldBtn: document.getElementById('biw-instructionsMiniForm').getElementsByTagName('button')[0],
            textInfo: document.getElementById('biw-instructionsMiniForm').getElementsByClassName('biw-textInfo')[0],
            input: document.getElementById('biw-instructionsMiniForm').getElementsByTagName('input')[0],
            confirmBtn: document.getElementById('biw-instructionsMiniForm').getElementsByTagName('button')[0]
        },

        buttonRefresh: document.getElementById('biw-buttonRefresh'),
        addressTypeList: document.getElementById('biw-addressTypeList'),
        globalTextInfo: document.getElementById('biw-globalTextInfo'),
    }

    activeAddressPrefix = null;
    activeAccountIndexByPrefix = { "W": 0, "C": 0, "P": 0, "U": 0 };
    generationTimeTextPerType = { "W": '~2sec', "C": '~30sec', "P": '~8min', "U": '~9.5h' }
    standardFeePerByte = { "fast": 12, "average": 5, "slow": 2 };
    activeMiniForm = null;
    currentTextInfo = '';
    textInfoTimeout1 = null;
    textInfoTimeout2 = null;
    ready = false;

	constructor(privateKey) {
        this.#init(privateKey);
	}

    async #onMessage(event) {
        try {
            const message = JSON.parse(event.data);
            const trigger = message.trigger;
            const data = message.data;
            switch (message.type) {
                case 'current_time':
                    console.log('current_time: disabled');
                    break;
                case 'address_exhaustive_data_requested':
                    //console.log('[BIW] sending address_exhaustive_data_requested to popup...');
                    //console.log('data:', data);
                    /*{
                        action: 'address_exhaustive_data_requested',
                        address: data.address,
                        UTXOs: data.addressUTXOs.UTXOs,
                        balance: data.addressUTXOs.balance,
                        spendableBalance: data.addressUTXOs.spendableBalance,
                        addressTxsReferences: data.addressTxsReferences,
                    }*/

                    //console.log(`[BIW] address_exhaustive_data_requested:`);
                    //console.log(data);
                    if (!this.wallet) { console.info('No active wallet'); return; }

                    const targetAccountAddressPrefix = data.address.slice(0, 1);
                    const targetAccountIndex = this.getWalletAccountIndexByAddress(data.address);
                    if (targetAccountIndex === -1) { console.error(`No account corresponding to address: ${data.address}`); return; }
                    const targetAccount = this.wallet.accounts[targetAccountAddressPrefix][targetAccountIndex];
                    if (!targetAccount) { console.error('No target account'); return; }
    
                    const { balance, spendableBalance, stakedBalance, spendableUTXOs } = await this.extractDataFromAccountUTXOs(data.addressUTXOs.UTXOs);
                    targetAccount.balance = balance;
                    targetAccount.spendableBalance = spendableBalance;
                    targetAccount.stakedBalance = stakedBalance;
                    targetAccount.UTXOs = spendableUTXOs;

                    if (targetAccountAddressPrefix !== this.activeAddressPrefix) { return; }

                    await this.updateTotalBalances();
                    this.updateAccountLabel(targetAccount);
                    break;
                case 'address_utxos_requested':
                    console.log('[BIW] sending address_utxos_requested to popup...');
                    /*{
                        action: 'address_utxos_requested',
                        address: data.address,
                        UTXOs: data.UTXOs,
                    }*/
                    break;
                case 'transaction_requested':
                    // { transaction, balanceChange, inAmount, outAmount, fee, txReference }
                    /** @type {TransactionWithDetails} */
                    const transactionWithDetails = data.transaction;
                    transactionWithDetails.balanceChange = data.balanceChange;
                    transactionWithDetails.inAmount = data.inAmount;
                    transactionWithDetails.outAmount = data.outAmount;
                    transactionWithDetails.fee = data.fee;
                    transactionWithDetails.txReference = data.txReference;
                    transactionsByReference[data.txReference] = transactionWithDetails;
        
                    //{ action: 'transaction_requested', transactionWithDetails };
                    break;
                case 'best_block_candidate_requested':
                    console.log('best_block_candidate_requested: disabled');
                    break;
                case 'transaction_broadcast_result':
                    console.log('[BIW] transaction_broadcast_result:', data);
                    //{action: 'transaction_broadcast_result', transaction: data.transaction,
                    // txId: data.txId, consumedAnchors: data.consumedAnchors, senderAddress: data.senderAddress,
                    // error: data.error, success: data.success});

                    const textInfoElement = this.eHTML[this.activeMiniForm]?.textInfo || this.eHTML.globalTextInfo;
                    if (data.error) {
                        this.textInfo(textInfoElement, data.error.replace(' | ', '\n'), 7000, true);
                    } else {
                        const textStr = `Transaction broadcasted!
                        TxId: ${data.txId} (pending confirmation ~2min)`;
                        this.textInfo(textInfoElement, textStr, 7000, true);
                    }
                    break;
                case 'subscribed_balance_update':
                    this.wsSubscriptions.balanceUpdates[data] = true;
                    console.log(`[BIW] subscribed_balance_update: ${data}`);
                    break;
                case 'subscribed_best_block_candidate_change':
                    console.log(`[BIW] subscribed_best_block_candidate_change`);
                    break;
                case 'balance_updated':
                    if (!this.wsSubscriptions.balanceUpdates[trigger]) { return; }
                    //console.log(`[BIW] balance_updated: ${trigger}`);
                    this.fetcher.send({ type: 'get_address_exhaustive_data', data: trigger });
                    break;
                case 'new_block_confirmed':
                    break;
                case 'best_block_candidate_changed':
                    console.log('best_block_candidate_changed: disabled');
                    break;
                case 'current_height':
                    break;
                default:
                    console.log(`[BIW] Unknown message type: ${message.type}`);
                    break;
            }
        } catch (error) { console.info(['onMessage] error:', error]); }
    }
    async #init(privateKey) {
        while (!window.modulesLoaded) { await new Promise(resolve => setTimeout(resolve, 100)); }
        this.fetcher = new WalletDataFetcher(this.#onMessage.bind(this));
        this.wallet = new window.Wallet(privateKey);
        await this.wallet.loadAccounts();
        await this.wallet.deriveGeneratedAccounts();
        this.switchAccountType('C');
        this.#initListeners();
        this.#initIpcListeners();

        if (this.wallet.accounts[this.activeAddressPrefix][0]) {
            for (let i = 0; i < this.wallet.accounts[this.activeAddressPrefix].length; i++) {
                const address = this.wallet.accounts[this.activeAddressPrefix][i].address;
                this.fetcher.send({ type: 'get_address_exhaustive_data', data: address });
                this.fetcher.send({ type: 'subscribe_balance_update', data: address });
            }
        }

        this.ready = true;
    }
    #initIpcListeners() {
        ipcRenderer.on('new-address-generated', async (event, data) => {
            if (!data) { console.error('No new address generated'); return; }
            console.log('new-address-generated:', data);
            
            this.newAddressBtnLoadingToggle();
            if (this.activeAddressPrefix !== data.slice(0, 1)) { return; }

            await this.wallet.loadAccounts();
            await this.wallet.deriveGeneratedAccounts(this.activeAddressPrefix);
            this.updateAccountsLabels();

            this.fetcher.send({ type: 'get_address_exhaustive_data', data });
                    
            if (this.wsSubscriptions.balanceUpdates[data]) { return; }
            this.fetcher.send({ type: 'subscribe_balance_update', data });
        });
    }
    #initListeners() {
        document.addEventListener('click', async (e) => {
            let target = e.target;
            switch (target.dataset.addresstype) {
                case 'W':
                case 'C':
                case 'P':
                case 'U':
                    if (target.classList.contains('disabled')) return;
                    this.switchAccountType(target.dataset.addresstype);
                    return;
            }

            switch (target.id) {
                case 'biw-buttonRefresh':
                    await this.refreshActiveAccounts();
                    break;
                case 'biw-newAddressBtn':
                    if (target.innerHTML !== '+') { console.log('Already generating new address'); return; }
        
                    this.newAddressBtnLoadingToggle();
                    this.textInfo(this.eHTML.globalTextInfo, `Generating new address... (${this.generationTimeTextPerType[this.activeAddressPrefix]})`, 7000);
                    ipcRenderer.send('generate-new-address', this.activeAddressPrefix);
                    break;
                case 'biw-buttonBarSend':
                    console.log('buttonBarSpend');
                    this.toggleMiniForm('send');
                    break;
                case 'biw-buttonBarSwap':
                    console.log('buttonBarSwap');
                    break;
                case 'biw-buttonBarStake':
                    console.log('buttonBarStake');
                    this.toggleMiniForm('stake');
                    break;
                case 'biw-buttonBarSpecial':
                    this.toggleMiniForm('special');
                    e.preventDefault();
                    break;
                case 'biw-buttonBarInstructions':
                    console.log('buttonBarInstructions');
                    this.toggleMiniForm('instructions');
                    break;
                case 'biw-buttonBarSpecialClaim':
                    console.log('buttonBarSpecialClaim');
                    break;
            }

            switch (target.className) {
                case 'biw-accountLabel':
                    this.selectAccountLabel(target);
                    break;
                case 'biw-accountImgWrap':
                    this.selectAccountLabel(target.parentElement);
                    break;
                case 'biw-followInstructionsBtn':
                    this.#followInstructionsFromInput();
                    break;
            }
        });

        document.addEventListener('mousedown', (e) => { // hold click
            const activeAccountIndex = this.activeAccountIndexByPrefix[this.activeAddressPrefix];
            /** @type {Account} */
            const senderAccount = this.wallet.accounts[this.activeAddressPrefix][activeAccountIndex];
            let amount;
            let receiverAddress;
            let feePerByte = this.standardFeePerByte.fast;
        
            switch (e.target.className) {
                case 'biw-sendBtn biw-holdBtn':
                    if (this.eHTML.send.amount.value === '') { this.textInfo(this.eHTML.send.textInfo, 'Amount is empty'); return; }
                    if (this.eHTML.send.toAddress.value === '') { this.textInfo(this.eHTML.send.textInfo, 'Address is empty'); return; }
                    if (this.animations.sendBtn) { this.animations.sendBtn.pause(); }
        
                    try { // Inform if address is invalid and avoid further processing
                        window.addressUtils.conformityCheck(this.eHTML.send.toAddress.value);
                    } catch (error) { this.textInfo(this.eHTML.send.textInfo, error.message); return; }
                    
                    this.refreshActiveAccounts();
                    this.animations.sendBtn = this.holdBtnMouseDownAnimation(e.target, async () => {
                        amount = parseInt(this.eHTML.send.amount.value.replace(",","").replace(".",""));
                        receiverAddress = this.eHTML.send.toAddress.value;

                        const createdSignedTx = await window.Transaction_Builder.createAndSignTransfer(senderAccount, amount, receiverAddress, feePerByte);
                        if (!createdSignedTx.signedTx) {
                            console.error('Transaction creation failed', createdSignedTx.error);
                            this.textInfo(this.eHTML.send.textInfo, createdSignedTx.error.message.replace(' | ', '\n'), 7000, true);
                            return;
                        }
                        
                        console.log('transaction:', createdSignedTx.signedTx);
                        this.fetcher.send({ type: 'broadcast_transaction', data: { transaction: createdSignedTx.signedTx, senderAddress: senderAccount.address } });
                        this.animations.sendBtn = null;
                    });
                    break;
                case 'biw-stakeBtn biw-holdBtn':
                    if (this.eHTML.stake.amount.value === '') { this.textInfo(this.eHTML.stake.textInfo, 'Amount is empty'); return; }
                    if (this.animations.stakeBtn) { this.animations.stakeBtn.pause(); this.animations.sendBtn = null; }
                    
                    this.refreshActiveAccounts();
                    this.animations.stakeBtn = this.holdBtnMouseDownAnimation(e.target, async () => {
                        console.log('stakeBtn');
                            amount = parseInt(this.eHTML.stake.amount.value.replace(",","").replace(".",""));
                            try {
                                const stakeOnAddress = this.eHTML.stake.toAddress.value;
                                window.addressUtils.conformityCheck(stakeOnAddress);

                                const createdTx = await window.Transaction_Builder.createStakingVss(senderAccount, stakeOnAddress, amount, feePerByte);
                                const signedTx = await senderAccount.signTransaction(createdTx);
                                console.log('transaction:', signedTx);
                                this.fetcher.send({ type: 'broadcast_transaction', data: { transaction: signedTx, senderAddress: senderAccount.address } });
                            } catch (error) {
                                this.textInfo(this.eHTML.stake.textInfo, error.message.replace(' | ', '\n'), 7000, true);
                            }
                            
                            this.animations.stakeBtn = null;
                    });
                    break;
            }
        });
        document.addEventListener('mouseup', (e) => { // release click
            switch (e.target.className) {
                case 'biw-sendBtn biw-holdBtn':
                    if (this.animations.sendBtn) {
                        this.animations.sendBtn.pause();
                        this.textInfo(this.eHTML.send.textInfo, 'Hold the button to confirm');
                    }
                    this.animations.sendBtn = this.holdBtnMouseUpAnimation(e.target);
                    break;
                case 'biw-stakeBtn biw-holdBtn':
                    if (this.animations.stakeBtn) {
                        this.animations.stakeBtn.pause();
                        this.textInfo(this.eHTML.stake.textInfo, 'Hold the button to confirm');
                    }
                    this.animations.stakeBtn = this.holdBtnMouseUpAnimation(e.target);
                    break;
            }
        });

        document.addEventListener('input', async (event) => {
            if (event.target.classList.contains('biw-amountInput')) {
                event.target.value = event.target.value.replace(/[^\d.]/g, '');
            }
            if (event.target === this.eHTML.send.toAddress
            || event.target === this.eHTML.stake.toAddress) {
                try {
                    window.addressUtils.conformityCheck(event.target.value);
                    event.target.classList.remove('invalid');
                } catch (error) { event.target.classList.add('invalid'); }
            }
        });
        document.addEventListener('keydown', (event) => {
            const target = event.target;
            if (event.key === 'Enter') {
                switch (target) {
                    case this.eHTML.instructions.input:
                        event.preventDefault();
                        this.#followInstructionsFromInput();
                        break;
                }
            }
        });
        document.addEventListener('paste', (event) => {
            const target = event.target;
            if (target === this.eHTML.instructions.input) {
                setTimeout(() => this.#followInstructionsFromInput(), 10);
            }
        });
        document.addEventListener('focusin', async (event) => {
            if (event.target.classList.contains('biw-amountInput')) event.target.value = '';
            if (event.target.classList.contains('biw-stakingInput')) this.eHTML.stake.stakingFee.innerText = '0.000000';
        });
        document.addEventListener('focusout', async (event) => {
            const target = event.target;
            if (target.classList.contains('biw-amountInput')) this.#updateAmountAndFeesRelatedToInput(target);
        });
        document.addEventListener('mouseover', (event) => {
            const target = event.target;
            const parent = target.parentElement;
            if (target.id === 'biw-addressTypeList' || parent.id === 'biw-addressTypeList') {
                this.eHTML.addressTypeList.classList.add('expand');
            } else { this.eHTML.addressTypeList.classList.remove('expand'); }

            switch (target.id) {
                case 'biw-buttonBarSpecial':
                    this.eHTML.specialMenu.classList.add('open');
                    this.eHTML.specialBtn.classList.add('open');
                    break;
                case 'specialMenu':
                    break;
                case 'biw-buttonBarInstructions':
                    break;
                case 'biw-buttonBarSpecialClaim':
                    break;
                default:
                    this.eHTML.specialMenu.classList.remove('open');
                    this.eHTML.specialBtn.classList.remove('open');
                    break;
            }
        });
    }
    #updateAmountAndFeesRelatedToInput(target) {
        const foldName = target.parentElement.parentElement.dataset.foldname;

        if (isNaN(parseFloat(target.value))) { target.value = ''; return; }
        target.value = parseFloat(target.value).toFixed(6);
        
        // update amount with currency format
        const amountMicro = parseInt(target.value.replace('.',''));
        const formatedValue = window.convert.formatNumberAsCurrency(amountMicro);
        console.log(`formated ${amountMicro} to ${formatedValue}`);
        target.value = formatedValue;
        
        // update totalSpent
        let totalSpentMicro = amountMicro;
        totalSpentMicro += parseInt(this.eHTML[foldName].txFee.innerText.replace('.',''));
        if (foldName === 'send') {
        } else if (foldName === 'stake') {
            this.eHTML.stake.stakingFee.innerText = `${formatedValue}`;
            totalSpentMicro += amountMicro;
        }
        
        this.eHTML[foldName].totalSpent.innerText = window.convert.formatNumberAsCurrency(totalSpentMicro);
    }
    #followInstructionsFromInput() {
        const instructions = this.instructionsReader.read(this.eHTML.instructions.input.value);
        this.eHTML.instructions.input.value = '';

        if (typeof instructions === 'string') {
            this.textInfo(this.eHTML.instructions.textInfo, instructions, 7000, true);
            return;
        }

        switch (instructions.action) {
            case 'SEND':
                if (!instructions.address) { this.textInfo(this.eHTML.instructions.textInfo, 'No address provided'); return; }
                if (!instructions.amount) { this.textInfo(this.eHTML.instructions.textInfo, 'No amount provided'); return; }
                this.eHTML.send.toAddress.value = instructions.address;
                this.eHTML.send.amount.value = instructions.amount;
                console.log(`instructions.amount: ${instructions.amount}`);
                this.toggleMiniForm('send');
                this.#updateAmountAndFeesRelatedToInput(this.eHTML.send.amount);
                this.textInfo(this.eHTML.send.textInfo, 'Read carefully the instructions result!', 3000, true);
                break;
            case 'STAKE':
                if (!instructions.address) { this.textInfo(this.eHTML.instructions.textInfo, 'No address provided'); return; }
                if (!instructions.amount) { this.textInfo(this.eHTML.instructions.textInfo, 'No amount provided'); return; }
                this.eHTML.stake.toAddress.value = instructions.address;
                this.eHTML.stake.amount.value = instructions.amount;
                this.toggleMiniForm('stake');
                this.#updateAmountAndFeesRelatedToInput(this.eHTML.stake.amount);
                this.textInfo(this.eHTML.stake.textInfo, 'Read carefully the instructions result!', 3000, true);
                break;
            case 'INSCRIBE':
                console.log('INSCRIBE');
                break;
        }
    }
    #setAccountPrefixButtonActive(prefix = "C") {
        const buttons = this.eHTML.addressTypeList.getElementsByTagName('button');
        for (const button of buttons) {
            if (button.textContent === prefix) button.classList.add('active');
            else button.classList.remove('active');
        }
    }
    switchAccountType(addressPrefix = "C") {
        if (this.activeAddressPrefix === addressPrefix) { return; }
        this.activeAddressPrefix = addressPrefix;
        this.#setAccountPrefixButtonActive(addressPrefix);
        this.updateAccountsLabels();

        const accountLabelToSelect = this.eHTML.accountsWrap.getElementsByClassName('biw-accountLabel')[this.activeAccountIndexByPrefix[addressPrefix] || 0];
        this.selectAccountLabel(accountLabelToSelect);
        this.updateTotalBalances();
    }
    async refreshActiveAccounts() {
        this.eHTML.buttonRefresh.classList.add('active');
        // refresh all accounts data
        for (let i = 0; i < this.wallet.accounts[this.activeAddressPrefix].length; i++) {
            const address = this.wallet.accounts[this.activeAddressPrefix][i].address;
            this.fetcher.send({ type: 'get_address_exhaustive_data', data: address });
            await new Promise((resolve) => setTimeout(() => resolve(), 10));
        }
        await new Promise((resolve) => setTimeout(() => resolve(), 1000));
        this.eHTML.buttonRefresh.classList.remove('active');
    }
    holdBtnMouseUpAnimation(target, invertColors = false, duration = 1000) {
        const leftColor = invertColors ? 'var(--color1)' : 'var(--color2)';
        const rightColor = invertColors ? 'var(--color2)' : 'var(--color1)';
        const initialBackground = `linear-gradient(90deg, ${leftColor} 0%, ${rightColor} 0%)`;
    
        return anime({
            targets: target,
            background: initialBackground,
            duration,
            easing: 'easeInOutQuad',
            complete: () => target.style.background = `linear-gradient(90deg, ${rightColor} 0%, ${leftColor} 0%)`
        });
    }
    holdBtnMouseDownAnimation(target, callback, invertColors = false, duration = 2000) {
        const computedStyle = getComputedStyle(target);
        const bImage = computedStyle.backgroundImage;
        const perc1 = bImage === 'none' ? 0 : bImage.split('%')[0].split(' ')[bImage.split('%')[0].split(' ').length - 1];
        const perc2 = bImage === 'none' ? 0 : bImage.split('%')[1].split(' ')[bImage.split('%')[1].split(' ').length - 1];
        
        const leftColor = invertColors ? 'var(--color1)' : 'var(--color2)';
        const rightColor = invertColors ? 'var(--color2)' : 'var(--color1)';
        target.style.background = `linear-gradient(90deg, ${leftColor} ${perc1}%, ${rightColor} ${perc2}%)`;
    
        return anime({
            targets: target,
            background: `linear-gradient(90deg, ${leftColor} 100%, ${rightColor} 102%)`,
            duration,
            easing: 'easeInOutQuad',
            complete: () => {
                callback();
                target.style.background = `linear-gradient(90deg, ${leftColor} 0%, ${rightColor} 0%)`;
            }
        });
    }
    textInfo(infoElmnt, text, timeout = 3000, eraseAnyCurrentTextInfo = false, important = false) {
        if (!eraseAnyCurrentTextInfo && this.currentTextInfo) { return; }

        this.currentTextInfo = text;
        infoElmnt.innerText = text;
        infoElmnt.style.opacity = '1';
        if (important) { infoElmnt.classList.add('important'); }

        if (this.textInfoTimeout1) { clearTimeout(this.textInfoTimeout1); }
        if (this.textInfoTimeout2) { clearTimeout(this.textInfoTimeout2); }
        this.textInfoTimeout1 = setTimeout(() => {
            this.currentTextInfo = null;
            infoElmnt.style.opacity = '0';
            infoElmnt.classList.remove('important');
        }, timeout);
        this.textInfoTimeout2 = setTimeout(() => { infoElmnt.innerText = ""; }, timeout + 200);
    }  
    #createAccountLabel(name, address, amount = 0) {
        const accountLabel = document.createElement('div');
        accountLabel.classList.add('biw-accountLabel');
    
        const accountImgWrap = document.createElement('div');
        accountImgWrap.classList.add('biw-accountImgWrap');
        accountLabel.appendChild(accountImgWrap);
        const accountImgWrapDivA = document.createElement('div');
        accountImgWrap.appendChild(accountImgWrapDivA);
        const accountImgWrapDivB = document.createElement('div');
        accountImgWrap.appendChild(accountImgWrapDivB);
        const img = patternGenerator.generateImage(address, UX_SETTINGS.shapes);
        accountImgWrap.appendChild(img);
    
        const accountLabelInfoWrap = document.createElement('div');
        accountLabelInfoWrap.classList.add('biw-accountLabelInfoWrap');
        accountLabel.appendChild(accountLabelInfoWrap);
    
        const accountLabelNameAndValueWrap = document.createElement('div');
        accountLabelNameAndValueWrap.classList.add('biw-accountLabelNameAndValueWrap');
        accountLabelInfoWrap.appendChild(accountLabelNameAndValueWrap);
    
        const h2 = document.createElement('h2');
        h2.innerText = name;
        accountLabelNameAndValueWrap.appendChild(h2);
    
        const h3 = document.createElement('h3');
        h3.innerText = `${window.convert.formatNumberAsCurrency(amount)}c`;
        accountLabelNameAndValueWrap.appendChild(h3);
    
        const accountLabelAddress = document.createElement('div');
        accountLabelAddress.classList.add('biw-accountLabelAddress');
        accountLabelInfoWrap.appendChild(accountLabelAddress);
    
        const h3Address = document.createElement('h3');
        h3Address.innerText = address;
        accountLabelAddress.appendChild(h3Address);
    
        return accountLabel;
    }
    /** @param {HTMLInputElement} accountLabel */
    selectAccountLabel(accountLabel) {
        const accountIndex = Array.from(accountLabel.parentElement.children).indexOf(accountLabel);
        this.activeAccountIndexByPrefix[this.activeAddressPrefix] = accountIndex;
        this.#updateActiveAccountLabel();
        this.#updateMiniFormsInfoRelatedToActiveAccount();

        const address = this.wallet.accounts[this.activeAddressPrefix][accountIndex].address;
        this.fetcher.send({ type: 'get_address_exhaustive_data', data: address });
    }
    #updateActiveAccountLabel() {
        const accountLabels = this.eHTML.accountsWrap.getElementsByClassName('biw-accountLabel');
        if (accountLabels.length === 0) { return; }
    
        const activeAccountIndex = this.activeAccountIndexByPrefix[this.activeAddressPrefix] || 0;
        for (let i = 0; i < accountLabels.length; i++) {
            accountLabels[i].classList.remove('active');
            if (i !== activeAccountIndex) { continue; }
            accountLabels[i].classList.add('active');
        }
    }
    #updateMiniFormsInfoRelatedToActiveAccount() {
        const activeAccount = this.wallet.accounts[this.activeAddressPrefix][this.activeAccountIndexByPrefix[this.activeAddressPrefix]];
        this.eHTML.send.senderAddress.innerText = activeAccount.address;
        this.eHTML.stake.senderAddress.innerText = activeAccount.address;

        if (this.eHTML.stake.toAddress.value !== '') return;
        const validatorAddress = this.wallet.accounts['C'][0].address;
        this.eHTML.stake.toAddress.value = validatorAddress;
    }
    updateAccountsLabels() {
        /** @type {Account[]} */
        const accounts = this.wallet.accounts[this.activeAddressPrefix];
        const accountLabels = this.eHTML.accountsWrap.getElementsByClassName('biw-accountLabel');
        const labelsToRemove = accountLabels.length - accounts.length;
        for (let i = 0; i < labelsToRemove; i++) {
            this.eHTML.accountsWrap.removeChild(accountLabels[accountLabels.length - 1]);
        }

        if (accounts.length === 0) { return; }

        const h2 = this.eHTML.accountsWrap.getElementsByTagName('h2');
        const h3 = this.eHTML.accountsWrap.getElementsByTagName('h3');
        for (let i = 0; i < accounts.length; i++) {
            const account = accounts[i];
            const accountName = `Account_${i + 1}`;
            const existingAccountLabel = accountLabels[i];
            if (existingAccountLabel) { // fill existing label
                //const name = existingAccountLabel.getElementsByClassName('biw-accountLabelNameAndValueWrap')[0].getElementsByTagName('h2')[0];
                //const address = existingAccountLabel.getElementsByClassName('biw-accountLabelAddress')[0].getElementsByTagName('h3')[0];
                //const amount = existingAccountLabel.getElementsByClassName('biw-accountLabelNameAndValueWrap')[0].getElementsByTagName('h3')[0];
                // DOM access to low on large lists -> faster but less consistent
                const name = h2[i];
                const amount = h3[i * 2];
                const address = h3[i * 2 + 1];

                if (address.innerText !== account.address) {
                    const img = patternGenerator.generateImage(account.address, UX_SETTINGS.shapes);
                    const accountImgWrap = existingAccountLabel.getElementsByClassName('biw-accountImgWrap')[0];
                    accountImgWrap.removeChild(accountImgWrap.getElementsByTagName('canvas')[0]);
                    accountImgWrap.appendChild(img);
                }

                const readableAmount = `${window.convert.formatNumberAsCurrency(account.balance)}c`;
                if (name.innerText !== accountName) name.innerText = accountName;
                if (address.innerText !== account.address) address.innerText = account.address;
                if (amount.innerText !== readableAmount) amount.innerText = readableAmount;
                continue;
            }
    
            const accountLabel = this.#createAccountLabel(accountName, account.address, account.balance);
            this.eHTML.accountsWrap.insertBefore(accountLabel, this.eHTML.newAddressBtn);
        }
    }
    /** @param {Account} account */
    updateAccountLabel(account) {
        let labelUpdated = false;
    
        const accountLabels = this.eHTML.accountsWrap.getElementsByClassName('biw-accountLabel');
        const h3 = this.eHTML.accountsWrap.getElementsByTagName('h3');
        for (let i = 0; i < accountLabels.length; i++) {
            //const address = accountLabels[i].getElementsByClassName('biw-accountLabelAddress')[0].getElementsByTagName('h3')[0];
            const address = h3[i * 2 + 1];
            if (address.innerText !== account.address) { continue; }
    
            //const amount = accountLabels[i].getElementsByClassName('biw-accountLabelNameAndValueWrap')[0].getElementsByTagName('h3')[0];
            const amount = h3[i * 2];
            amount.innerText = `${window.convert.formatNumberAsCurrency(account.balance)}c`;
            labelUpdated = true;
            break;
        }
        
        if (!labelUpdated) {
            const accountLabel = this.#createAccountLabel(`Account ${i + 1}`, account.address, account.balance);
            this.eHTML.accountsWrap.insertBefore(accountLabel, this.eHTML.newAddressBtn);
        }
    
        //console.log(`Account label updated: ${account.address}`);
    }
    async updateTotalBalances(onlyActiveAddressType = true) {
        let walletTotalBalance = 0;
        let walletTotalSpendableBalance = 0;
        let walletTotalStakedBalance = 0;
        
        const addressTypes = Object.keys(this.wallet.accounts);
        for (let i = 0; i < addressTypes.length; i++) {
            const addressPrefix = addressTypes[i];
            if (onlyActiveAddressType && addressPrefix !== this.activeAddressPrefix) { continue; }
            
            const showInLabelsWrap = addressPrefix === this.activeAddressPrefix;
            const { totalBalance, totalSpendableBalance, totalStakedBalance } = this.#calculateTotalOfBalances(addressPrefix, showInLabelsWrap);
            walletTotalBalance += totalBalance;
            walletTotalSpendableBalance += totalSpendableBalance;
            walletTotalStakedBalance += totalStakedBalance;
        }
    
        this.eHTML.spendableBalanceStr.innerText = window.convert.formatNumberAsCurrency(walletTotalSpendableBalance);
        this.eHTML.stakedStr.innerText = window.convert.formatNumberAsCurrency(walletTotalStakedBalance);
    
        //console.log(`[POPUP] totalBalances updated: ${walletTotalBalance}c, from ${this.wallet.accounts[this.activeAddressPrefix].length} accounts`);
    }
    #calculateTotalOfBalances(addressPrefix = defaultAddressPrefix) {
        let totalBalance = 0;
        let totalSpendableBalance = 0;
        let totalStakedBalance = 0;
        const nbOfAccounts = this.wallet.accounts[addressPrefix].length;
        for (let i = 0; i < nbOfAccounts; i++) {
            const account = this.wallet.accounts[addressPrefix][i];
            totalBalance += account.balance;
            totalSpendableBalance += account.spendableBalance;
            totalStakedBalance += account.stakedBalance || 0;
        }
    
        return { totalBalance, totalSpendableBalance, totalStakedBalance };
    }
    newAddressBtnLoadingToggle() {
        const isGenerating = this.eHTML.newAddressBtn.innerHTML !== '+';
    
        if (isGenerating) {
            this.eHTML.newAddressBtn.classList.remove('loading');
            if (this.animations.newAddressBtn) { this.animations.newAddressBtn.pause(); }
            this.animations.newAddressBtn = anime({
                targets: this.eHTML.newAddressBtn,
                width: '34px',
                duration: 200,
                easing: 'easeInOutQuad',
                complete: () => { 
                    this.eHTML.newAddressBtn.innerHTML = '+';
                    this.animations.newAddressBtn = null; 
                }
            });
        } else {
            this.eHTML.newAddressBtn.classList.add('loading');
            this.eHTML.newAddressBtn.innerHTML = horizontalBtnLoading;
            if (this.animations.newAddressBtn) { this.animations.newAddressBtn.pause(); }
            this.animations.newAddressBtn = anime({
                targets: this.eHTML.newAddressBtn,
                width: ['80px', '200px', '80px'],
                duration: 1600,
                loop: true,
                easing: 'easeInOutQuad'
            });
        }
    }
    getWalletAccountIndexByAddress(address = '') {
        const targetAddressPrefix = address.slice(0, 1);
        const addressTypes = Object.keys(this.wallet.accounts);
        for (let i = 0; i < addressTypes.length; i++) {
            const addressPrefix = addressTypes[i];
            if (addressPrefix !== targetAddressPrefix) { continue; }
    
            const accounts = this.wallet.accounts[addressPrefix];
            for (let j = 0; j < accounts.length; j++) {
                if (accounts[j].address === address) { return j; }
            }
        }
        return -1;
    }
    /** @param {UTXO[]} utxos */
    async extractDataFromAccountUTXOs(utxos) {
        let balance = 0;
        let spendableBalance = 0;
        let stakedBalance = 0;
        const spendableUTXOs = [];

        for (const utxo of utxos) {
            balance += utxo.amount;
            if (utxo.rule === 'sigOrSlash') { stakedBalance += utxo.amount; continue; }

            spendableUTXOs.push(utxo);
            spendableBalance += utxo.amount;
        }

        return { balance, spendableBalance, stakedBalance, spendableUTXOs };
    }
    /** @param {string | boolean} foldName - false to close all */
    #setButtonBarActiveButton(foldName = "send") {
        const buttons = this.eHTML.buttonBar.element.getElementsByTagName('button');
        for (const button of buttons) button.classList.remove('active');

        if (!foldName) return;

        let targetBtnName = foldName;
        if (targetBtnName === 'instructions') targetBtnName = 'special';
        if (targetBtnName === 'claim') targetBtnName = 'special';

        this.eHTML.buttonBar[targetBtnName].classList.add('active');
    }
    /** @param {HTMLElement} foldName */
    toggleMiniForm(foldName = "send") {
        this.#updateMiniFormsInfoRelatedToActiveAccount();

        this.eHTML.send.miniForm.classList.remove('active');
        this.eHTML.stake.miniForm.classList.remove('active');
        this.eHTML.instructions.miniForm.classList.remove('active');

        if (foldName === 'special') {
            if (!this.activeMiniForm) return;
            this.#setButtonBarActiveButton(false);
            this.activeMiniForm = null;
            this.eHTML.container.classList.remove('expand');
            return;
        }

        if (this.activeMiniForm === foldName) {
            this.#setButtonBarActiveButton(false);
            this.activeMiniForm = null;
            this.eHTML.container.classList.remove('expand');
        } else {
            this.#setButtonBarActiveButton(foldName);
            this.activeMiniForm = foldName;
            this.eHTML[foldName].miniForm.classList.add('active');
            this.eHTML.container.classList.add('expand');
        }
    }
}

module.exports = { BoardInternalWallet };